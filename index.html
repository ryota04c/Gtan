<!DOCTYPE html>
<html>
<head>
    <title>2信号シミュレーション</title>
    <style>
        <!--描画枠の設定-->
        canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>
    <!--描画枠の設定-->
<canvas id="trafficCanvas" width="400" height="1800"></canvas>

    <!--描画枠の設定-->
<script>
//描画枠
const canvas = document.getElementById("trafficCanvas");
const ctx = canvas.getContext("2d");
//パラメーター取得
const PARAMS_URL = "https://script.google.com/macros/s/AKfycbwBBFI6Q_l6yj1cqzOlR9kJa4iaqqnxHiIEBD3vIWCHl4jZLTUAOuL-pYGVu2U_2u40/exec"; 
    
let settings = {};
let cars = [];
//信号配置
const signals = [
    {   
        x:{
            right:206,
            left:194
            },
        y: {
            top:394,
            bottom:406
        },
        state: 'green', 
        timer: 0, 
        id: 'signal1' 
    },
    {   
        x:{
            right:206,
            left:194
            },
        y: {
            top:1394,
            bottom:1406
        },
        state: 'green', 
        timer: 0, 
        id: 'signal2' 
    },
];

let time = 0;
// パラメータを取得してからシミュレーション開始
fetch(PARAMS_URL)
    .then(res => res.json())
    .then(data => {
        settings = {
            signal1: {
                green: parseInt(data.params.signal1_green),
                yellow: parseInt(data.params.signal1_yellow),
                red: parseInt(data.params.signal1_red)
            },
            signal2: {
                green: parseInt(data.params.signal2_green),
                yellow: parseInt(data.params.signal2_yellow),
                red: parseInt(data.params.signal2_red)
            },
                car_spawn_rate: parseInt(data.params.car_spawn_rate),
                car_speed_max: parseFloat(data.params.car_speed_max_kmh) / 3.6,
                car_length: parseFloat(data.params.car_length_m),
                acceleration: parseFloat(data.params.acceleration_mps2)
        };
        mapList = data.map;

        setInterval(spawnCar1, settings.car_spawn_rate);
        requestAnimationFrame(loop);
    });

//車の出現
function spawnCar1() {
    let routeRandom = Math.random();
    let route = 
        routeRandom < 0.05 ? ["A","B","E"]:
        routeRandom < 0.10 ? ["A","B","F"]:
        routeRandom < 0.15 ? ["A","B","C","G"]:
        routeRandom < 0.20 ? ["A","B","C","H"]:
        ["A","B","C","D"];
    cars.push({
        x: 204.5,
        y: 0,
        speed: settings.car_speed_max,
        targetSpeed: settings.car_speed_max,
        route:route,
        routeIndex:0,
        traveled :0 ,
        routeMax:route.length-2 ,
        finished : 0,
        totalLength : 0,
        runTime : 0,
        crowdTime: 0,
        crowdLength: 0,
        feeling: 0,
        CO2 : 0
        
    });
    
}

//信号の更新
function updateSignals(delta) {
    for (let sig of signals) {//信号の数だけ繰り返す
        sig.timer += delta;
        const conf = settings[sig.id];//信号名に応じてJSONを取得する
        const totalCycle = conf.green + conf.yellow + conf.red;
        let t = sig.timer % totalCycle;//信号の動きを周期化する
    
        if (t < conf.green) {
             sig.state = 'green';
        } else if (t < conf.green + conf.yellow) {
            sig.state = 'yellow';
        } else {
            sig.state = 'red';
        }
    }
}

//車の更新
function updateCars(delta) {
    const carWidth = settings.car_length;
    const carLength = 2;
    for (let i = 0 ; i < cars.length ; i++) {
        const car = cars[i];

        // ルートが終わっているならスキップ
        if (car.routeIndex > car.routeMax) continue;
        
        let stop = false;

        // 区間情報取得
        let currentFrom = car.route[car.routeIndex];
        let currentTo = car.route[car.routeIndex + 1];
        let section = mapList.find(s => s.from === currentFrom && s.to === currentTo);
        if (!section) continue;
        const distanceInSection = section.distance;
        
        //車の先頭の座標記録
        const carFrontX = car.x+carWidth/2*Math.cos(section.direction_arg * Math.PI);
        const carFrontY = car.y-carWidth/2*Math.sin(section.direction_arg * Math.PI);
        
        //車の停止距離を認識
        let stopLength = car.speed*car.speed/(2*settings.acceleration) + car.speed*0.75;
        //高速域では速度に応じた誤差を導入
        if(car.speed > 4.17)stopLength += car.speed*Math.random()/3;

        // --------- ① 同じ区間内の前方車チェック ---------
        let foundFrontCar = false;
        for (let j = 0; j < cars.length; j++) {
            if (j === i) continue;
            const other = cars[j];
            
            for (let k=0; k< other.routeMax+1;k++){
                if (
                    other.route[k] === currentFrom &&
                    other.route[k + 1] === currentTo
                ) {
                    let gap = other.traveled-car.traveled
    
                    if (stopLength+10 > gap && gap>0) {
                        stop = true;
                        foundFrontCar = true;
                        break;
                    }
                }
            }
        }

        // --------- ② 次区間の前方車チェック ---------
        if (!foundFrontCar && car.routeIndex + 2 < car.route.length) {
            let nextFrom = car.route[car.routeIndex + 1];
            let nextTo = car.route[car.routeIndex + 2];
            let nextSection = mapList.find(s => s.from === nextFrom && s.to === nextTo);

            let minDistance = Infinity;

            for (let j = 0; j < cars.length; j++) {
                if (j === i) continue;
                const other = cars[j];
                for (let k=0; k< other.routeMax +1; k++){
                    if (
                        other.route[k] === nextFrom &&
                        other.route[k + 1] === nextTo
                    ) {
                        const distanceRemaining = distanceInSection - car.traveled;
                        const totalGap = distanceRemaining + other.traveled;
                        if (totalGap < minDistance) {
                            minDistance = totalGap;
                        }
                    }
                }
            }

            if (minDistance !== Infinity) {
                if (stopLength+5 > minDistance){
                    stop = true;
                }
            }
        }

        // --------- ③ 信号による停止判定 ---------
        let onsig = false
        let sigInf = {};
        //来た方面に合わせた信号のnoと方向
        if(currentFrom === "A"){
            onsig = true;
            sigInf = {
                no: 0,
                shaft : 'y',
                direction: 'top'
            };  
        }else if(currentFrom === "B"){
            onsig = true;
            sigInf = {
              no: 1,
              shaft: 'y',
              direction: 'top'
            }  
        }
        if(onsig){
            const signalData = signals[sigInf.no];
            const sigShaft = signalData[sigInf.shaft];
            const sigPoint = sigShaft[sigInf.direction];
            const carPoint = car.y;
            const signalGap = Math.abs(sigPoint-carPoint);
            if((signalData.state === "red" || signalData.state === "yellow") &&
                (sigPoint - carPoint) > 0 &&
                signalGap <= stopLength+2.5)
            {
                stop = true;
            }
                
        }

        // --------- ④ 加減速処理 ---------
        if (stop) {
            car.speed = Math.max(0, car.speed - settings.acceleration * (delta / 1000));
        } else {
            car.speed = Math.min(car.targetSpeed, car.speed + settings.acceleration * (delta / 1000));
        }

        // --------- ⑤ 移動と区間更新 ---------
        const moveDistance = car.speed * (delta / 1000);
        const speed2 = car.speed*3.6;
        car.traveled += moveDistance;
        car.runTime += delta/1000;
        car.totalLength += moveDistance;
        car.CO2 += (0.0406*speed2*speed2 - 6.17*speed2 + 389.89)*moveDistance/1000;
        if(speed2 <= 15 && speed2 !== 0){
            car.crowdTime += delta/1000;
            car.crowdLength += moveDistance;
        }else if(speed2 > 15&&car.crowdTime !== 0){
            const feelingBase = car.crowdLength/car.crowdTime * 3.6;
            const feelingNew = feelingBase* car.crowdTime;
            car.feeling = Math.max(car.feeling,feelingNew);
            car.crowdTime = 0;
            car.crowdLength = 0;
        }
        //移動処理
        car.x += moveDistance*Math.cos(section.direction_arg*Math.PI);
        car.y -= moveDistance*Math.sin(section.direction_arg*Math.PI);

        if (car.traveled >= distanceInSection) {
            car.routeIndex++;
            car.traveled = 0;
        }

        // --------- ⑥ ルート終了判定 ---------
        if (car.routeIndex >= car.route.length - 1) {
            console.log("ルート終了 → 除外:", car.route);
            car.finish = 1;
            sendResultToSheet(car);
        }
    }

    // --------- ⑦ 画面外 or 終了車両の除去 ---------
    cars = cars.filter(car => car.finish !== 1 &&
        car.x >= -50 && car.x <= canvas.width + 50 &&
        car.y >= -50 && car.y <= canvas.height + 50);
}
//データ転送
function sendResultToSheet(car) {
  fetch("https://script.google.com/macros/s/AKfycbxF6ldhtbvAFX1fiEX_A1MvNNFt9iCTGS3-rrKuH_waXvdeVBTFbZAKWUTxOXB6Xixn/exec", {
    method: "POST",
    headers: {
      "Content-Type": "text/plain"  // ← ここが超重要！
    },
    body: JSON.stringify({
      feeling: car.feeling,
      runTime: car.runTime,   // ← runTime の typo 修正も！
      totalLength: car.totalLength,
      CO2: car.CO2
    })
  })
  .then(res => res.text())
  .then(data => console.log("送信成功:", data))
  .catch(err => console.error("送信失敗:", err));
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 道路
    ctx.fillStyle = "#aaa";
    ctx.fillRect(194, 0, 12, canvas.height);
    ctx.fillRect(0, 394, canvas.width,12);
    ctx.fillRect(0, 1394, canvas.width,12);
    
    // 信号描画
    for (let sig of signals) {
        ctx.fillStyle = sig.state;
        ctx.beginPath();
        ctx.arc(sig.x.left-4, sig.y.top-4, 4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // 車描画
    for (let car of cars) {
        let speedRatio = car.speed / car.targetSpeed;
        const carWidth = settings.car_length;
        const carLength = 2;
    
        // 安全に範囲内に収める
        if (!isFinite(speedRatio) || isNaN(speedRatio)) {
            speedRatio = 0;
        }
        speedRatio = Math.max(0, Math.min(1, speedRatio));
        
        //色変更
        if (car.speed === 0) {
            ctx.fillStyle = "black"; // 停止中
        } else {
            let hue = 0 + (240 - 0) * speedRatio;
            let lightness = 20 + 30 * speedRatio; // 速度ゼロ→20%、速度MAX→50%
            ctx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
        }
        // 向きごとに描画
        const section = mapList.find(s =>
            s.from === car.route[car.routeIndex] &&
            s.to === car.route[car.routeIndex + 1]
        );
        if (!section) continue;
    
        ctx.save();
        ctx.translate(car.x, car.y);
    
        // 回転角
        let angle = section.direction_arg*Math.PI;
    
        ctx.rotate(angle);
        ctx.fillRect(-carWidth / 2, -carLength / 2, carWidth, carLength);
        ctx.restore();
}

}

//経過時間の取得
let lastTime = performance.now();
//ループ処理
function loop(now) {
    let delta = now - lastTime;
    lastTime = now;

    updateSignals(delta);
    updateCars(delta);
    draw();
    requestAnimationFrame(loop);
}
</script>
</body>
</html>
